import typing as t
from ..types import AbstractTypeVisitor as AbstractTypeVisitor, AnyMeta as AnyMeta, BooleanMeta as BooleanMeta, FloatMeta as FloatMeta, GenericMeta as GenericMeta, IntegerMeta as IntegerMeta, MappingMeta as MappingMeta, OptionalMeta as OptionalMeta, Record as Record, RecordMeta as RecordMeta, SequenceMeta as SequenceMeta, StringMeta as StringMeta, TypeRefMeta as TypeRefMeta
from .errors import Errors as Errors
from _typeshed import Incomplete
from hiku.graph import Field as Field, Graph as Graph, GraphVisitor as GraphVisitor, Link as Link, Node as Node, Nothing as Nothing, Option as Option, Root as Root
from hiku.query import Field as QueryField, Link as QueryLink, Node as QueryNode, QueryVisitor as QueryVisitor

OptionValue: Incomplete

class _AssumeRecord(AbstractTypeVisitor):
    def __init__(self, data_types: t.Dict[str, t.Type[Record]], _nested: bool = ...) -> None: ...
    def visit(self, obj: t.Any) -> t.Any: ...
    visit_any: Incomplete
    visit_boolean: Incomplete
    visit_string: Incomplete
    visit_integer: Incomplete
    visit_float: Incomplete
    visit_mapping: Incomplete
    visit_callable: Incomplete
    def visit_optional(self, obj: OptionalMeta) -> t.Optional[t.OrderedDict]: ...
    def visit_sequence(self, obj: SequenceMeta) -> t.Optional[t.OrderedDict]: ...
    def visit_record(self, obj: RecordMeta) -> t.OrderedDict: ...
    def visit_typeref(self, obj: TypeRefMeta) -> t.OrderedDict: ...

class _AssumeField(GraphVisitor):
    node: Incomplete
    errors: Incomplete
    def __init__(self, node: Node, errors: Errors) -> None: ...
    def visit_field(self, obj: Field) -> bool: ...
    def visit_link(self, obj: Link) -> bool: ...
    def visit_node(self, obj: Node) -> bool: ...
    def visit_root(self, obj: Root) -> t.NoReturn: ...

class _OptionError(TypeError):
    description: Incomplete
    def __init__(self, description: str) -> None: ...

class _OptionTypeError(_OptionError):
    def __init__(self, value: OptionValue, expected: GenericMeta) -> None: ...

class _OptionTypeValidator:
    def __init__(self, data_types: t.Dict[str, t.Type[Record]], value: OptionValue) -> None: ...
    @property
    def value(self) -> OptionValue: ...
    def push(self, value: OptionValue) -> t.Iterator[None]: ...
    def visit(self, type_: GenericMeta) -> None: ...
    def visit_any(self, type_: AnyMeta) -> None: ...
    def visit_boolean(self, type_: BooleanMeta) -> None: ...
    def visit_string(self, type_: StringMeta) -> None: ...
    def visit_integer(self, type_: IntegerMeta) -> None: ...
    def visit_float(self, type_: FloatMeta) -> None: ...
    def visit_optional(self, type_: OptionalMeta) -> None: ...
    def visit_sequence(self, type_: SequenceMeta) -> None: ...
    def visit_mapping(self, type_: MappingMeta) -> None: ...
    def visit_record(self, type_: RecordMeta) -> None: ...
    def visit_typeref(self, type_: TypeRefMeta) -> None: ...

class _ValidateOptions(GraphVisitor):
    options: Incomplete
    for_: Incomplete
    errors: Incomplete
    def __init__(self, data_types: t.Dict[str, t.Type[Record]], options: t.Optional[t.Dict], for_: t.Tuple[t.Any, ...], errors: Errors) -> None: ...
    def visit_link(self, obj: Link) -> None: ...
    visit_field: Incomplete
    def visit_option(self, obj: Option) -> None: ...
    def visit_node(self, obj: Node) -> None: ...
    def visit_root(self, obj: Root) -> t.NoReturn: ...

class _RecordFieldsValidator(QueryVisitor):
    def __init__(self, data_types: t.Dict[str, t.Type[Record]], field_types: t.OrderedDict, errors: Errors) -> None: ...
    def visit_field(self, obj: QueryField) -> None: ...
    def visit_link(self, obj: QueryLink) -> None: ...
    def visit_node(self, obj: QueryNode) -> None: ...

class QueryValidator(QueryVisitor):
    graph: Incomplete
    path: Incomplete
    errors: Incomplete
    def __init__(self, graph: Graph) -> None: ...
    def visit_field(self, obj: QueryField) -> None: ...
    def visit_link(self, obj: QueryLink) -> None: ...
    def visit_node(self, obj: QueryNode) -> None: ...

def validate(graph: Graph, query: QueryNode) -> t.List[str]: ...
