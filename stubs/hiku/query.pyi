import typing as t
from .utils import cached_property as cached_property
from _typeshed import Incomplete
from collections import OrderedDict

T: Incomplete

class Base:
    __attrs__: t.Tuple[str, ...]
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...
    def copy(self, **kwargs: t.Any) -> T: ...

class FieldBase(Base):
    name: str
    options: t.Optional[t.Dict[str, t.Any]]
    alias: t.Optional[str]
    def result_key(self) -> str: ...
    def options_hash(self) -> t.Optional[int]: ...
    def index_key(self) -> str: ...

class Field(FieldBase):
    __attrs__: Incomplete
    name: Incomplete
    options: Incomplete
    alias: Incomplete
    def __init__(self, name: str, options: t.Optional[t.Dict[str, t.Any]] = ..., alias: t.Optional[str] = ...) -> None: ...
    def accept(self, visitor: QueryVisitor) -> t.Any: ...

class Link(FieldBase):
    __attrs__: Incomplete
    name: Incomplete
    node: Incomplete
    options: Incomplete
    alias: Incomplete
    def __init__(self, name: str, node: Node, options: t.Optional[t.Dict[str, t.Any]] = ..., alias: t.Optional[str] = ...) -> None: ...
    def accept(self, visitor: QueryVisitor) -> t.Any: ...

class Node(Base):
    __attrs__: Incomplete
    fields: Incomplete
    ordered: Incomplete
    def __init__(self, fields: t.List[t.Union[Field, Link]], ordered: bool = ...) -> None: ...
    def fields_map(self) -> OrderedDict: ...
    def result_map(self) -> OrderedDict: ...
    def accept(self, visitor: QueryVisitor) -> t.Any: ...

def merge(nodes: t.Iterable[Node]) -> Node: ...

class QueryVisitor:
    def visit(self, obj: t.Any) -> t.Any: ...
    def visit_field(self, obj: Field) -> t.Any: ...
    def visit_link(self, obj: Link) -> t.Any: ...
    def visit_node(self, obj: Node) -> t.Any: ...

class QueryTransformer:
    def visit(self, obj: t.Any) -> t.Any: ...
    def visit_field(self, obj: Field) -> Field: ...
    def visit_link(self, obj: Link) -> Link: ...
    def visit_node(self, obj: Node) -> Node: ...
