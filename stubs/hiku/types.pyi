import abc
import typing as t
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from collections import OrderedDict

class GenericMeta(type):
    def __eq__(cls, other: t.Any) -> bool: ...
    def __ne__(cls, other: t.Any) -> bool: ...
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class AnyMeta(GenericMeta):
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class Any(metaclass=AnyMeta): ...

class BooleanMeta(GenericMeta):
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class Boolean(metaclass=BooleanMeta): ...

class StringMeta(GenericMeta):
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class String(metaclass=StringMeta): ...

class IntegerMeta(GenericMeta):
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class Integer(metaclass=IntegerMeta): ...

class FloatMeta(GenericMeta):
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class Float(metaclass=FloatMeta): ...

TM: Incomplete

class TypingMeta(GenericMeta):
    __final__: bool
    def __cls_init__(cls, parameters: t.Any) -> None: ...
    def __cls_repr__(cls) -> str: ...
    def __getitem__(cls, parameters: t.Any) -> TM: ...
    def __hash__(self) -> int: ...

class OptionalMeta(TypingMeta):
    __type__: GenericMeta
    def __cls_init__(cls, type_: GenericMeta) -> None: ...
    def __cls_repr__(self) -> str: ...
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class Optional(metaclass=OptionalMeta): ...

class SequenceMeta(TypingMeta):
    __item_type__: GenericMeta
    def __cls_init__(cls, item_type: GenericMeta) -> None: ...
    def __cls_repr__(self) -> str: ...
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class Sequence(metaclass=SequenceMeta): ...

class MappingMeta(TypingMeta):
    __key_type__: GenericMeta
    __value_type__: GenericMeta
    def __cls_init__(cls, params: t.Tuple[GenericMeta, GenericMeta]) -> None: ...
    def __cls_repr__(self) -> str: ...
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class Mapping(metaclass=MappingMeta): ...

class RecordMeta(TypingMeta):
    __field_types__: OrderedDict
    def __cls_init__(cls, field_types: t.Union[t.Dict[str, GenericMeta], t.List[t.Tuple[str, GenericMeta]]]) -> None: ...
    def __cls_repr__(self) -> str: ...
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class Record(metaclass=RecordMeta):
    __field_types__: OrderedDict

class CallableMeta(TypingMeta):
    def __cls_init__(cls, arg_types: t.Iterable[GenericMeta]) -> None: ...
    def __cls_repr__(self) -> str: ...
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class Callable(metaclass=CallableMeta): ...

class TypeRefMeta(TypingMeta):
    __type_name__: str
    def __cls_init__(cls, *args: str) -> None: ...
    def __cls_repr__(self) -> str: ...
    def accept(cls, visitor: AbstractTypeVisitor) -> t.Any: ...

class TypeRef(metaclass=TypeRefMeta): ...

class AbstractTypeVisitor(ABC, metaclass=abc.ABCMeta):
    def visit(self, obj: GenericMeta) -> t.Any: ...
    @abstractmethod
    def visit_any(self, obj: AnyMeta) -> t.Any: ...
    @abstractmethod
    def visit_boolean(self, obj: BooleanMeta) -> t.Any: ...
    @abstractmethod
    def visit_string(self, obj: StringMeta) -> t.Any: ...
    @abstractmethod
    def visit_integer(self, obj: IntegerMeta) -> t.Any: ...
    @abstractmethod
    def visit_float(self, obj: FloatMeta) -> t.Any: ...
    @abstractmethod
    def visit_typeref(self, obj: TypeRefMeta) -> t.Any: ...
    @abstractmethod
    def visit_optional(self, obj: OptionalMeta) -> t.Any: ...
    @abstractmethod
    def visit_sequence(self, obj: SequenceMeta) -> t.Any: ...
    @abstractmethod
    def visit_mapping(self, obj: MappingMeta) -> t.Any: ...
    @abstractmethod
    def visit_record(self, obj: RecordMeta) -> t.Any: ...
    @abstractmethod
    def visit_callable(self, obj: CallableMeta) -> t.Any: ...

class TypeVisitor(AbstractTypeVisitor):
    def visit_any(self, obj: AnyMeta) -> t.Any: ...
    def visit_boolean(self, obj: BooleanMeta) -> t.Any: ...
    def visit_string(self, obj: StringMeta) -> t.Any: ...
    def visit_integer(self, obj: IntegerMeta) -> t.Any: ...
    def visit_float(self, obj: FloatMeta) -> t.Any: ...
    def visit_typeref(self, obj: TypeRefMeta) -> t.Any: ...
    def visit_optional(self, obj: OptionalMeta) -> t.Any: ...
    def visit_sequence(self, obj: SequenceMeta) -> t.Any: ...
    def visit_mapping(self, obj: MappingMeta) -> t.Any: ...
    def visit_record(self, obj: RecordMeta) -> t.Any: ...
    def visit_callable(self, obj: CallableMeta) -> t.Any: ...


@t.overload
def get_type(types: t.Dict[str, t.Type[Record]], typ: TypeRefMeta) -> t.Type[Record]: ...
@t.overload
def get_type(types: t.Dict[str, t.Type[Record]], typ: GenericMeta) -> GenericMeta: ...
@t.overload
def get_type(types: t.Dict[str, t.Type[Record]], typ: t.Optional[GenericMeta]) -> t.Optional[GenericMeta]: ...
