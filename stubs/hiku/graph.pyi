import abc
import typing as t
from .directives import DirectiveBase as DirectiveBase
from .sources.graph import BoundExpr as BoundExpr, SubGraph as SubGraph
from .types import Any as Any, AnyMeta as AnyMeta, GenericMeta as GenericMeta, Optional as Optional, OptionalMeta as OptionalMeta, Record as Record, Sequence as Sequence, SequenceMeta as SequenceMeta, TypeRef as TypeRef, TypeRefMeta as TypeRefMeta, TypingMeta as TypingMeta
from .utils import Const as Const, cached_property as cached_property, const as const
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from collections import OrderedDict
from typing import List
from typing_extensions import TypeAlias

Maybe: Incomplete
One: Incomplete
Many: Incomplete
Nothing: Incomplete
NothingType: TypeAlias = Const

class AbstractBase(ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def accept(self, visitor: AbstractGraphVisitor) -> None: ...

class AbstractOption(AbstractBase, ABC, metaclass=abc.ABCMeta): ...

class Option(AbstractOption):
    name: Incomplete
    type: Incomplete
    default: Incomplete
    description: Incomplete
    def __init__(self, name: str, type_: t.Optional[GenericMeta], *, default: t.Any = ..., description: t.Optional[str] = ...) -> None: ...
    def accept(self, visitor: AbstractGraphVisitor) -> t.Any: ...

class AbstractField(AbstractBase, ABC, metaclass=abc.ABCMeta): ...

R: Incomplete
SyncAsync: Incomplete
RootFieldFunc: Incomplete
NotRootFieldFunc: Incomplete
NotRootFieldFuncCtx: Incomplete
FieldType: Incomplete
FieldFunc: Incomplete

class Field(AbstractField):
    name: Incomplete
    type: Incomplete
    func: Incomplete
    options: Incomplete
    description: Incomplete
    directives: Incomplete
    def __init__(self, name: str, type_: FieldType, func: FieldFunc, *, options: t.Optional[t.Sequence[Option]] = ..., description: t.Optional[str] = ..., directives: t.Optional[t.Sequence[DirectiveBase]] = ...) -> None: ...
    def options_map(self) -> OrderedDict: ...
    def accept(self, visitor: AbstractGraphVisitor) -> t.Any: ...

class AbstractLink(AbstractBase, ABC, metaclass=abc.ABCMeta): ...

LinkType: Incomplete

def get_type_enum(type_: TypingMeta) -> t.Tuple[Const, str]: ...

LT: Incomplete
LR: Incomplete
MaybeLink: Incomplete
RootLinkT: Incomplete
LinkT: Incomplete
RootLinkOne = RootLinkT[LR]
RootLinkMaybe = RootLinkT[MaybeLink[LR]]
RootLinkMany = RootLinkT[List[LR]]
LinkOne = LinkT[LT, List[LR]]
LinkMaybe = LinkT[LT, List[MaybeLink[LR]]]
LinkMany = LinkT[LT, List[List[LR]]]
LinkFunc: Incomplete
LinkOneFunc: Incomplete
LinkMaybeFunc: Incomplete
LinkManyFunc: Incomplete

class Link(AbstractLink):
    @t.overload
    def __init__(self, name: str, type_: t.Type[TypeRef], func: LinkOneFunc, *, requires: t.Optional[str], options: t.Optional[t.Sequence[Option]] = ..., description: t.Optional[str] = ..., directives: t.Optional[t.Sequence[DirectiveBase]] = ...) -> None: ...
    @t.overload
    def __init__(self, name: str, type_: t.Type[Optional], func: LinkMaybeFunc, *, requires: t.Optional[str], options: t.Optional[t.Sequence[Option]] = ..., description: t.Optional[str] = ..., directives: t.Optional[t.Sequence[DirectiveBase]] = ...) -> None: ...
    @t.overload
    def __init__(self, name: str, type_: t.Type[Sequence], func: LinkManyFunc, *, requires: t.Optional[str], options: t.Optional[t.Sequence[Option]] = ..., description: t.Optional[str] = ..., directives: t.Optional[t.Sequence[DirectiveBase]] = ...) -> None: ...
    def options_map(self) -> OrderedDict: ...
    def accept(self, visitor: AbstractGraphVisitor) -> t.Any: ...

class AbstractNode(AbstractBase, ABC, metaclass=abc.ABCMeta): ...

class Node(AbstractNode):
    name: Incomplete
    fields: Incomplete
    description: Incomplete
    directives: Incomplete
    def __init__(self, name: t.Optional[str], fields: t.List[t.Union[Field, Link]], *, description: t.Optional[str] = ..., directives: t.Optional[t.Sequence[DirectiveBase]] = ...) -> None: ...
    def fields_map(self) -> OrderedDict: ...
    def accept(self, visitor: AbstractGraphVisitor) -> t.Any: ...

class Root(Node):
    def __init__(self, items: t.List[t.Union[Field, Link]]) -> None: ...
    def accept(self, visitor: AbstractGraphVisitor) -> t.Any: ...

class AbstractGraph(AbstractBase, ABC, metaclass=abc.ABCMeta): ...

class Graph(AbstractGraph):
    items: Incomplete
    data_types: Incomplete
    __types__: Incomplete
    def __init__(self, items: t.List[Node], data_types: t.Optional[t.Dict[str, t.Type[Record]]] = ...) -> None: ...
    def iter_root(self) -> t.Iterator[t.Union[Field, Link]]: ...
    def iter_nodes(self) -> t.Iterator[t.Union[Node]]: ...
    def root(self) -> Root: ...
    def nodes(self) -> t.List[Node]: ...
    def nodes_map(self) -> OrderedDict: ...
    def accept(self, visitor: AbstractGraphVisitor) -> t.Any: ...

class AbstractGraphVisitor(ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def visit(self, obj: t.Any) -> t.Any: ...
    @abstractmethod
    def visit_option(self, obj: Option) -> t.Any: ...
    @abstractmethod
    def visit_field(self, obj: Field) -> t.Any: ...
    @abstractmethod
    def visit_link(self, obj: Link) -> t.Any: ...
    @abstractmethod
    def visit_node(self, obj: Node) -> t.Any: ...
    @abstractmethod
    def visit_root(self, obj: Root) -> t.Any: ...
    @abstractmethod
    def visit_graph(self, obj: Graph) -> t.Any: ...

class GraphVisitor(AbstractGraphVisitor):
    def visit(self, obj: t.Any) -> t.Any: ...
    def visit_option(self, obj: Option) -> t.Any: ...
    def visit_field(self, obj: Field) -> t.Any: ...
    def visit_link(self, obj: Link) -> t.Any: ...
    def visit_node(self, obj: Node) -> t.Any: ...
    def visit_root(self, obj: Root) -> t.Any: ...
    def visit_graph(self, obj: Graph) -> t.Any: ...

class GraphTransformer(AbstractGraphVisitor):
    def visit(self, obj: t.Any) -> t.Any: ...
    def visit_option(self, obj: Option) -> Option: ...
    def visit_field(self, obj: Field) -> Field: ...
    def visit_link(self, obj: Link) -> Link: ...
    def visit_node(self, obj: Node) -> Node: ...
    def visit_root(self, obj: Root) -> Root: ...
    def visit_graph(self, obj: Graph) -> Graph: ...

def apply(graph: Graph, transformers: List[GraphTransformer]) -> Graph: ...

class GraphInit(GraphTransformer):
    @classmethod
    def init(cls, items: t.List[Node]) -> t.List[Node]: ...
    def visit_field(self, obj: Field) -> Field: ...
    def visit_link(self, obj: Link) -> Link: ...

class GraphTypes(GraphVisitor):
    @classmethod
    def get_types(cls, items: t.List[Node], data_types: t.Dict[str, t.Type[Record]]) -> t.Dict[str, t.Type[Record]]: ...
    def visit_graph(self, obj: Graph) -> t.Dict[str, t.Type[Record]]: ...
    def visit_node(self, obj: Node) -> t.Type[Record]: ...
    def visit_root(self, obj: Root) -> t.Type[Record]: ...
    def visit_link(self, obj: Link) -> LinkType: ...
    def visit_field(self, obj: Field) -> t.Union[FieldType, AnyMeta]: ...
