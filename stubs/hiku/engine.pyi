from .executors.base import SyncAsyncExecutor as SyncAsyncExecutor
from .executors.queue import Queue as Queue, SubmitRes as SubmitRes, TaskSet as TaskSet, Workflow as Workflow
from .graph import Field as Field, Graph as Graph, Link as Link, Many as Many, Maybe as Maybe, Node as Node, Nothing as Nothing, One as One
from .query import Field as QueryField, Link as QueryLink, Node as QueryNode, QueryTransformer as QueryTransformer, QueryVisitor as QueryVisitor
from .result import Index as Index, Proxy as Proxy, ROOT as ROOT, Reference as Reference
from _typeshed import Incomplete
from collections.abc import Mapping
from typing import Any, Awaitable, Callable, Dict, Iterator, List, NoReturn, Optional, Tuple, TypeVar, Union
from typing_extensions import Concatenate, ParamSpec

class InitOptions(QueryTransformer):
    def __init__(self, graph: Graph) -> None: ...
    def visit_field(self, obj: QueryField) -> QueryField: ...
    def visit_link(self, obj: QueryLink) -> QueryLink: ...
FieldGroup = Tuple[Field, Union[QueryField, QueryLink]]
CallableFieldGroup = Tuple[Callable, Field, Union[QueryField, QueryLink]]
LinkGroup = Tuple[Link, QueryLink]

class SplitQuery(QueryVisitor):
    def __init__(self, graph_node: Node) -> None: ...
    def split(self, query_node: QueryNode) -> Tuple[List[CallableFieldGroup], List[LinkGroup]]: ...
    def visit_node(self, obj: QueryNode) -> NoReturn: ...
    def visit_field(self, obj: QueryField) -> None: ...
    def visit_link(self, obj: QueryLink) -> None: ...

class GroupQuery(QueryVisitor):
    def __init__(self, node: Node) -> None: ...
    def group(self, node: QueryNode) -> List[Tuple[Callable, Union[List[FieldGroup], LinkGroup]]]: ...
    def visit_node(self, obj: QueryNode) -> NoReturn: ...
    def visit_field(self, obj: QueryField) -> None: ...
    def visit_link(self, obj: QueryLink) -> None: ...

def store_fields(index: Index, node: Node, query_fields: List[Union[QueryField, QueryLink]], ids: Optional[Any], query_result: Any) -> None: ...
def link_reqs(index: Index, node: Node, link: Link, ids: Any) -> Any: ...
def link_ref_maybe(graph_link: Link, ident: Any) -> Optional[Reference]: ...
def link_ref_one(graph_link: Link, ident: Any) -> Reference: ...
def link_ref_many(graph_link: Link, idents: List) -> List[Reference]: ...

HASH_HINT: str
DATACLASS_HINT: str

def store_links(index: Index, node: Node, graph_link: Link, query_link: QueryLink, ids: Any, query_result: Any) -> None: ...
def link_result_to_ids(from_list: Any, link_type: Any, result: Any) -> List: ...

class Query(Workflow):
    def __init__(self, queue: Queue, task_set: TaskSet, graph: Graph, query: QueryNode, ctx: Context) -> None: ...
    def start(self) -> None: ...
    def result(self) -> Proxy: ...
    def process_node(self, node: Node, query: QueryNode, ids: Any) -> None: ...
    def process_link(self, node: Node, graph_link: Link, query_link: QueryLink, ids: Any, result: Any) -> None: ...
R = TypeVar('R')
P = ParamSpec('P')

def pass_context(func: Callable[P, R]) -> Callable[Concatenate['Context', P], R]: ...

class Context(Mapping):
    def __init__(self, mapping: Mapping) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator: ...
    def __getitem__(self, item: Any) -> Any: ...

class Engine:
    executor: Incomplete
    def __init__(self, executor: SyncAsyncExecutor) -> None: ...
    def execute(self, graph: Graph, query: QueryNode, ctx: Optional[Dict] = ...) -> Union[Proxy, Awaitable[Proxy]]: ...
